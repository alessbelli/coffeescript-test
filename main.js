// Generated by CoffeeScript 1.12.7
var argument, find_possible_partition, fit_rules, group_sizes, input, is_peaceful, is_quiet, maybe_quiet_groups, maybe_understanding_groups, partition_arrangement, partition_format, permute, understands,
  slice = [].slice;

import fs from 'fs';

group_sizes = function(input) {
  var j, min_group_size, nb_students, ref, remainder, results, students;
  students = input.students;
  nb_students = students.length;
  remainder = nb_students % input.groups;
  min_group_size = (nb_students - remainder) / input.groups;
  if (remainder) {
    return slice.call((function() {
        var j, ref, results;
        results = [];
        for (j = 1, ref = remainder; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
          results.push(min_group_size + 1);
        }
        return results;
      })()).concat(slice.call((function() {
        var j, ref, ref1, results;
        results = [];
        for (j = ref = remainder + 1, ref1 = input.groups; ref <= ref1 ? j <= ref1 : j >= ref1; ref <= ref1 ? j++ : j--) {
          results.push(min_group_size);
        }
        return results;
      })()));
  } else {
    results = [];
    for (j = 1, ref = input.groups; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
      results.push(min_group_size);
    }
    return results;
  }
};

is_quiet = function(group) {
  return group.filter(function(student) {
    return student.noisy;
  }).length < 3;
};

understands = function(group) {
  return group.filter(function(student) {
    return student.understands;
  }).length > 0;
};

is_peaceful = function(group) {
  var fightees, fighters, student;
  fighters = (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = group.length; j < len; j++) {
      student = group[j];
      results.push(student.name);
    }
    return results;
  })();
  fightees = [].concat.apply([], (function() {
    var j, len, results;
    results = [];
    for (j = 0, len = group.length; j < len; j++) {
      student = group[j];
      results.push(student.fights_with);
    }
    return results;
  })());
  return !fightees.filter(function(student_name) {
    return -1 !== fighters.indexOf(student_name);
  }).length;
};

fit_rules = function(groups) {
  return groups.every(function(group) {
    return is_quiet(group) && understands(group) && is_peaceful(group);
  });
};

maybe_quiet_groups = function(input) {
  return input.students.filter(function(student) {
    return student.noisy;
  }).length <= 2 * input.groups;
};

maybe_understanding_groups = function(input) {
  return input.students.filter(function(student) {
    return student.understands;
  }).length >= input.groups;
};

permute = function*(permutation) {
  var c, i, k, length, p, results;
  length = permutation.length;
  c = (function() {
    var j, ref, results;
    results = [];
    for (j = 1, ref = length; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
      results.push(0);
    }
    return results;
  })();
  i = 1;
  yield permutation.slice();
  results = [];
  while (i < length) {
    if (c[i] < i) {
      k = i % 2 && c[i];
      p = permutation[i];
      permutation[i] = permutation[k];
      permutation[k] = p;
      ++c[i];
      i = 1;
      results.push((yield permutation.slice()));
    } else {
      c[i] = 0;
      results.push(++i);
    }
  }
  return results;
};

partition_arrangement = function(arrangement) {
  var current_index, group_size, j, len, partition, ref;
  partition = [];
  current_index = 0;
  ref = group_sizes(input);
  for (j = 0, len = ref.length; j < len; j++) {
    group_size = ref[j];
    partition.push(arrangement.slice(current_index, +(current_index + group_size - 1) + 1 || 9e9));
    current_index += group_size;
  }
  return partition;
};

partition_format = function(partition) {
  var group, j, len, results, student;
  results = [];
  for (j = 0, len = partition.length; j < len; j++) {
    group = partition[j];
    results.push((function() {
      var l, len1, results1;
      results1 = [];
      for (l = 0, len1 = group.length; l < len1; l++) {
        student = group[l];
        results1.push(student.name);
      }
      return results1;
    })());
  }
  return results;
};

find_possible_partition = function(input) {
  var arrangement, partition, ref;
  if (!(maybe_understanding_groups(input) && maybe_quiet_groups(input))) {
    return {
      error: "impossible, too few groups!"
    };
  }
  ref = permute(input.students);
  for (arrangement of ref) {
    partition = partition_arrangement(arrangement);
    if (fit_rules(partition)) {
      return partition_format(partition);
    }
  }
  return {
    error: "impossible"
  };
};

if (process.argv.length === 3) {
  argument = process.argv.pop();
  if (argument.slice(-5) === ".json") {
    input = JSON.parse(fs.readFileSync(argument));
    console.log(find_possible_partition(input));
  }
} else {
  console.log('{ "error": "please input filename as argument" }');
}
